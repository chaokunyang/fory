# C++ Generated API Design

This document describes the public API generated by the Fory compiler for C++ types.

## Goals

- Keep accessors consistent for get/set operations where setters exist.
- Return numeric values by value (no references).
- Provide clear ownership for message fields.

## Naming Conventions

- Getters are named `<field>()` (no `get_` prefix).
- Setters (when emitted) use the `set_` prefix.
- Optional fields expose `has_` and `clear_` helpers.
- Message fields expose `mutable_` for in-place updates.

## Field Accessors

### Numeric primitive fields

Numeric primitives include:

- `bool`
- signed and unsigned integers (`int8_t` ... `uint64_t`, varint/tagged variants)
- floating point (`float`, `double`)

Generated API:

```cpp
value_type <field>() const;
void set_<field>(value_type value);
```

Notes:

- `<field>()` returns by value.
- For optional numeric fields, `<field>()` returns the contained value and assumes `has_<field>()` is true.

Enums follow the same rule as numeric primitives: getters and setters use by-value types.

### Non-numeric value fields

Applies to non-numeric value types like `fory::serialization::Date`, `fory::serialization::Timestamp`.

Generated API:

```cpp
const value_type& <field>() const;
void set_<field>(value_type value);
```

Notes:

- `<field>()` returns a const reference.

### String fields

Strings return by const reference, provide `mutable_<field>()`, and use a forwarding setter.

Generated API:

```cpp
const std::string& <field>() const;
std::string* mutable_<field>();
template <class Arg, class... Args>
void set_<field>(Arg&& arg, Args&&... args);
```

Notes:

- `set_<field>(...)` forwards to `std::string` construction.

### Collection, bytes, union, and message fields

For list/map/bytes/union/message fields, the generator provides `mutable_<field>()` and does not emit a setter.

Generated API:

```cpp
const value_type& <field>() const;
value_type* mutable_<field>();
```

### Optional fields

Optional fields add presence helpers:

```cpp
bool has_<field>() const;
void clear_<field>();
```

Accessors follow the rules above (numeric by value, non-numeric by const reference).

### Message fields

Message fields are stored as `std::unique_ptr<T>` and expose:

```cpp
bool has_<field>() const;
const T& <field>() const;
T* mutable_<field>();
void clear_<field>();
```

Notes:

- `mutable_<field>()` lazily allocates the message if it is missing.
- `<field>()` assumes `has_<field>()` is true.

## Example

Given FDL:

```text
message User {
  string name = 1;
  int32 age = 2;
  optional string email = 3;
}
```

Generated API (simplified):

```cpp
class User final {
public:
  const std::string& name() const;
  std::string* mutable_name();
  template <class Arg, class... Args>
  void set_name(Arg&& arg, Args&&... args);

  int32_t age() const;
  void set_age(int32_t value);

  bool has_email() const;
  const std::string& email() const;
  std::string* mutable_email();
  template <class Arg, class... Args>
  void set_email(Arg&& arg, Args&&... args);
  void clear_email();

  bool operator==(const User& other) const;
private:
  std::string name_;
  int32_t age_;
  std::optional<std::string> email_;
public:
  FORY_STRUCT(User, name_, age_, email_);
};
```
